# -*- coding: utf-8 -*-
"""elec378_spring2024_hw1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yOTgYtnH7o_8IOOWZ9YDvqoq_j0JODdz

# problem 1
"""

import numpy as np
import matplotlib.pyplot as plt

#When in doubt use np.shape() to check if a numpy matrix has the right shape.

#Also note that while hints are included in this colab, there are a lot of ways
#to solve the problem not necessarily using the hints. If the hints are helpful
#that's great, but don't feel like you have to use them.

# max dimension to simulate
D = ?

# store the estimated volume in each dimension
volume = np.squeeze(np.zeros((1,D)))

#Hint: Consider using the np.linalg.norm() method to find the l_p norm

# in d dimensions ...
for d in np.arange(1,D):
  # generate N random vectors uniformly distributed throughout the ell-infinity ball
  # and stack them as rows in the matrix X
  N = ?
  X = ?

  # estimate the volume between the ell-infinity and ell-2 ball using the random samples
  volume[d] = ?

plt.plot(volume)
plt.show()

"""# problem 3"""

from scipy.io import loadmat
from scipy.io.wavfile import write
import numpy as np
import IPython

data = loadmat('cauchy_schwarz_decoding.mat')

y = data['y']
c0 = data['c0']
c1 = data['c1']

# construct the matrix C which contains as columns the carriers c0 and c1
#Hint: Consider using np.squeeze and np.column_stack.

C = ?

# construct the matrix Y which contains as rows the received (noisy) carrier
# tones corresponding to each transmitted bit
# the width of Y should be equal to the length of one carrier tone.

#Hint: Think about how you can reshape y.

Y = ?

# use matrix multiplication of C and Y to compute the sequence of inner products
# between each received (noisy) carrier tone and each known carrier tone (c0 and c1)
S = ?

# use argmax to decode according to cauchy schwarz
# bits should have shape (N,) where N is the number of decoded bits
bits = np.argmax(np.abs(S), ?)

# conversion from binary to uint8
# please feel free to use this code if you're having trouble writing your own
# if you are given any errors, ensure your bits have shape (N,) for appropriate N
strResult = ''.join(str(n) for n in bits)
byteResult = list(int(strResult[i : i+8][::-1], 2) for i in range(0, len(strResult), 8))
arrayResult = np.asarray([byteResult]).astype('uint8')
# writing decoded bits as a .jpg
# include this image in your submission
f = open('decoded.jpg','wb')
f.write(arrayResult)
f.close()

# construct the matrix X which contains in its i^th column the carrier tone
# corresponding to the i^th bit transmitted
X = C[:,?]

# construct the signal x(t) by playing the carrier tones in sequence
x = X.flatten('F')

y = y.flatten()

# listen to the noisy received signal y(t) vs your denoised reconstruction x(t)
fs = 44100
write("y.wav",fs,y)
write("x.wav",fs,x)
# if the code below does not work in google colab, you can download the wav files
# and listen locally on your prefered audio player
IPython.display.Audio("y.wav")
IPython.display.Audio("x.wav")
