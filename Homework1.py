# -*- coding: utf-8 -*-
"""Elec378HW1CauchySchwarz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SW1briReTPSRXeUrn_AQpNm4RMVYeSzo

Problem 1
"""

import random
import numpy as np

#dimensions
for d in range(1,10):
  outside = 0
  #run simulations per dimension
  for i in range(1,100000):
    #generate vector
    vector = np.random.rand(d) * 2 - 1

    #find the 2 norm
    current = 0
    for value in vector:
      current += value**2
    current = current**0.5

    #check where the vector lives
    if current > 1:
      outside = outside+1
  print(outside/100000)

"""1B. In higher dimensions, most of the volume is outside of the $L_2$ ball. The intuition in $R^2$ is that some of the volume is outside of the ball,and that it increases as you go up in dimensions. Most vectors live outside of the $L_2$ ball in higher dimensions.

3a. Let's create a matrix that has c0 in column 1 (index 0) and c1 in column 2 (index 1). Let's then multiply that matrix by a matrix containing the data of the received signal (reshaped to allow for matrix multiplication), which gives us a matrix containing the innerproducts of the received data with each of the carrier waveforms. Finally, for each row in the matrix, we can take the greater absolute value of the two column entries, with the index corresponding to the transmitted bit. This works because of the Cauchy-Schwarz Inequality, which states that the absolute value of the inner product must be between 0 and the product of the 2-norms. The closer the two vectors are to the product of the 2-norms, the more similar they are. Therefore, the greater the inner product, the more similar it is to the respective singal, and the more likely it is that the signal is a 0 or 1 (depending on the index of the column).

3b. Yes, I see the poop emoji output in the jpg file.

3c. The corrupt signal sounds like static over a a changing frequency. The x(t) signal sounds like y(t) with little/no static. While the x(t) doesn't sound like anything decipherable to a human ear, it appears to be alternating between two frequencies very rapidly. I am satisfied with the system's performance.
"""

from scipy.io import loadmat
from scipy.io.wavfile import write
import numpy as np
import IPython



mat = loadmat('cauchy_schwarz_decoding.mat')
y = mat['y']
c0 = mat['c0']
c1 = mat['c1']

C = np.column_stack((np.squeeze(c0),np.squeeze(c1)))
Y = np.reshape(y,(-1,len(np.squeeze(c0))))
S = np.matmul(Y,C)

bits = np.argmax(np.abs(S),axis = 1)



strResult = ''.join(str(n)for n in bits)
byteResult = list(int(strResult[i:i+8][::-1],2) for i in range(0,len(strResult),8))
arrayResult = np.asarray([byteResult]).astype('uint8')
f = open('decoded.jpg','wb')
f.write(arrayResult)
f.close


X = C[:,bits]
x = X.flatten('F')
y = y.flatten()
fs = 44100
write("y.wav",fs,y)
write("x.wav",fs,x)

IPython.display.Audio("y.wav")
IPython.display.Audio("x.wav")
