# -*- coding: utf-8 -*-
"""Elec378HW2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SNbDTM5weajolJORAHge8unxx8ZEXM6G
"""

import scipy.io as sc
from scipy import signal
import numpy as np
import matplotlib.pyplot as plt
import time
import struct
from PIL import Image
from scipy.io import loadmat
from scipy.io.wavfile import write
import IPython

"""Problem 2

a. See the plot below
b. The image should be very well approximated by a matrix of rank ~50 or higher. The approximation gets very poor for a matrix of rank ~20 or lower, as demonstrated by the negative logarithmic curve in the plot.
c. See images below.
"""

img = Image.open('Elec378HW2.jpg').convert('L')
image_array = np.array(img)

# Perform Singular Value Decomposition (SVD)
# hint: there is one function you can use that will do the entire SVD for you
U, S, Vt = np.linalg.svd(image_array)

# Plot the singular values
plt.plot(S, marker='o')
plt.title("Singular Values of the Image")
plt.xlabel("Singular Value Index")
plt.ylabel("Singular Value Magnitude")
plt.show()

# Let K be the rank of the reconstruction
K = 20

# Perform low-rank approximation
S_low_rank = np.zeros((U.shape[1],Vt.shape[0]))
np.fill_diagonal(S_low_rank, S)

# Zero out the smaller singular values for low-rank approximation
S_low_rank[K:] = 0

# Reconstruct the image using the modified singular values
image_low_rank = U @ S_low_rank @ Vt

# Display the original and low-rank approximated images
plt.subplot(1, 2, 1)
plt.imshow(image_array, cmap='gray')
plt.title("Original Image")

plt.subplot(1, 2, 2)
plt.imshow(image_low_rank, cmap='gray')
plt.title(f"Low Rank Approximation (K={K})")

plt.show()

"""Problem 4

a. Steps:
1. Identify the chirps
  Convolve y2, the input signal, with the reversed chirp signal.

  Imagine this as sliding the chirp signal along the input signal, finding where the two are more similar.

2. Find the peaks/range

  Find the peaks in the convolution. Peaks in this convolution mean that it is likely a match for the chirp.

  These peaks correspond to the start and end points of the chirp signals.

3. Extract the signal

  Extract the BFSK in the same manner as in HW 1.

The Cauchy-Schwarz inequality states that for all vectors U and V, the absolute value of the inner porduct is between zero and the product of the two norms. The convolution operation can be thought of as calculating a series of inner products. For each shift of the chirp over the input signal, the convolution operation is computing the inner product of the chirp with a segment of the recorded signal.
By the Cauchy-Schwarz inequality, the maximum value of the inner product (and the convolution) occurs when the segments of the signals are similar. Therefore, peaks in the convolution indicate points in the input signal that are highly similar to the chirp signal.

b. Yes, I see the toilet emoji.
"""

a = sc.loadmat('cauchy_schwarz_decoding.mat')
b = sc.loadmat('cauchy_schwarz_decoding_2.mat')

# Extract variables
y2 = np.squeeze(b['y2'])
chrp = np.squeeze(b['chrp'])
c0 = np.squeeze(a['c0'])
c1 = np.squeeze(a['c1'])

# Convolve y2 with the time-reversed chirp signal
conv = signal.convolve(y2, np.flip(chrp))


peaks, _ = signal.find_peaks(conv, height=np.max(conv) * 0.85)
start_peak = peaks[0]
end_peak = peaks[-1]

midpoint = (start_peak + end_peak) // 2

start = np.argmax(conv[:midpoint])
end = np.argmax(conv[midpoint:])+midpoint - L_chrp




# Extract the BFSK
y= y2[start:end]

C = np.column_stack((c0,c1))
Y = np.reshape(y,(-1,len(c0)))
S = np.matmul(Y,C)

bits = np.argmax(np.abs(S),axis = 1)

strResult = ''.join(str(n)for n in bits)
byteResult = list(int(strResult[i:i+8][::-1],2) for i in range(0,len(strResult),8))
arrayResult = np.asarray([byteResult]).astype('uint8')
f = open('decoded.jpg','wb')
f.write(arrayResult)
f.close()
